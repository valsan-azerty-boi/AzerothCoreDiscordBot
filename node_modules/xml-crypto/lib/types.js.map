{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":";AAAA,mCAAmC;AACnC,6CAA6C;AAC7C,0DAA0D;AAC1D,oEAAoE;AACpE,qEAAqE;;;AAwLrE;;;;;;;;;;;;;;;;;;;;GAoBG;AAEH,SAAS,oBAAoB,CAC3B,gBAAyB;IAEzB,OAAO,OAAO,gBAAgB,KAAK,UAAU,CAAC;AAChD,CAAC;AAED;;;;;GAKG;AACH,SAAgB,8BAA8B,CAC5C,WAA8B;IAK9B,OAAO,CAAC,CAAC,GAAG,IAAuC,EAAE,EAAE;QACrD,MAAM,gBAAgB,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QAC/C,IAAI,oBAAoB,CAAC,gBAAgB,CAAC,EAAE,CAAC;YAC3C,IAAI,CAAC;gBACH,MAAM,MAAM,GAAG,WAAW,CAAC,GAAI,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAO,CAAC,CAAC;gBACxD,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;YACjC,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;gBACb,gBAAgB,CAAC,GAAG,YAAY,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC;YAC5E,CAAC;QACH,CAAC;aAAM,CAAC;YACN,OAAO,WAAW,CAAC,GAAI,IAAU,CAAC,CAAC;QACrC,CAAC;IACH,CAAC,CAGA,CAAC;AACJ,CAAC;AAtBD,wEAsBC","sourcesContent":["/* eslint-disable no-unused-vars */\r\n// Type definitions for @node-saml/xml-crypto\r\n// Project: https://github.com/node-saml/xml-crypto#readme\r\n// Original definitions by: Eric Heikes <https://github.com/eheikes>\r\n//                          Max Chehab <https://github.com/maxchehab>\r\n\r\n/// <reference types=\"node\" />\r\n\r\nimport * as crypto from \"crypto\";\r\n\r\nexport type ErrorFirstCallback<T> = (err: Error | null, result?: T) => void;\r\n\r\nexport type CanonicalizationAlgorithmType =\r\n  | \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"\r\n  | \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\"\r\n  | \"http://www.w3.org/2001/10/xml-exc-c14n#\"\r\n  | \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\"\r\n  | string;\r\n\r\nexport type CanonicalizationOrTransformAlgorithmType =\r\n  | CanonicalizationAlgorithmType\r\n  | \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\";\r\n\r\nexport type HashAlgorithmType =\r\n  | \"http://www.w3.org/2000/09/xmldsig#sha1\"\r\n  | \"http://www.w3.org/2001/04/xmlenc#sha256\"\r\n  | \"http://www.w3.org/2001/04/xmlenc#sha512\"\r\n  | string;\r\n\r\nexport type SignatureAlgorithmType =\r\n  | \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"\r\n  | \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"\r\n  | \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\"\r\n  | \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\"\r\n  | string;\r\n\r\n/**\r\n * @param cert the certificate as a string or array of strings (@see https://www.w3.org/TR/2008/REC-xmldsig-core-20080610/#sec-X509Data)\r\n * @param prefix an optional namespace alias to be used for the generated XML\r\n */\r\nexport interface GetKeyInfoContentArgs {\r\n  publicCert?: crypto.KeyLike;\r\n  prefix?: string | null;\r\n}\r\n\r\n/**\r\n * Options for the SignedXml constructor.\r\n */\r\nexport interface SignedXmlOptions {\r\n  idMode?: \"wssecurity\";\r\n  idAttribute?: string;\r\n  privateKey?: crypto.KeyLike;\r\n  publicCert?: crypto.KeyLike;\r\n  signatureAlgorithm?: SignatureAlgorithmType;\r\n  canonicalizationAlgorithm?: CanonicalizationAlgorithmType;\r\n  inclusiveNamespacesPrefixList?: string | string[];\r\n  implicitTransforms?: ReadonlyArray<CanonicalizationOrTransformAlgorithmType>;\r\n  keyInfoAttributes?: Record<string, string>;\r\n  getKeyInfoContent?(args?: GetKeyInfoContentArgs): string | null;\r\n  getCertFromKeyInfo?(keyInfo?: Node | null): string | null;\r\n}\r\n\r\nexport interface NamespacePrefix {\r\n  prefix: string;\r\n  namespaceURI: string;\r\n}\r\n\r\nexport interface RenderedNamespace {\r\n  rendered: string;\r\n  newDefaultNs: string;\r\n}\r\n\r\nexport interface CanonicalizationOrTransformationAlgorithmProcessOptions {\r\n  defaultNs?: string;\r\n  defaultNsForPrefix?: Record<string, string>;\r\n  ancestorNamespaces?: NamespacePrefix[];\r\n  signatureNode?: Node | null;\r\n  inclusiveNamespacesPrefixList?: string[];\r\n}\r\n\r\nexport interface ComputeSignatureOptionsLocation {\r\n  reference?: string;\r\n  action?: \"append\" | \"prepend\" | \"before\" | \"after\";\r\n}\r\n\r\n/**\r\n * Options for the computeSignature method.\r\n *\r\n * - `prefix` {String} Adds a prefix for the generated signature tags\r\n * - `attrs` {Object} A hash of attributes and values `attrName: value` to add to the signature root node\r\n * - `location` {{ reference: String, action: String }}\r\n * - `existingPrefixes` {Object} A hash of prefixes and namespaces `prefix: namespace` already in the xml\r\n *   An object with a `reference` key which should\r\n *   contain a XPath expression, an `action` key which\r\n *   should contain one of the following values:\r\n *   `append`, `prepend`, `before`, `after`\r\n */\r\nexport interface ComputeSignatureOptions {\r\n  prefix?: string;\r\n  attrs?: Record<string, string>;\r\n  location?: ComputeSignatureOptionsLocation;\r\n  existingPrefixes?: Record<string, string>;\r\n}\r\n\r\n/**\r\n * Represents a reference node for XML digital signature.\r\n */\r\nexport interface Reference {\r\n  // The XPath expression that selects the data to be signed.\r\n  xpath?: string;\r\n\r\n  // An array of transforms to be applied to the data before signing.\r\n  transforms: ReadonlyArray<CanonicalizationOrTransformAlgorithmType>;\r\n\r\n  // The algorithm used to calculate the digest value of the data.\r\n  digestAlgorithm: HashAlgorithmType;\r\n\r\n  // The URI that identifies the data to be signed.\r\n  uri: string;\r\n\r\n  // Optional. The digest value of the referenced data.\r\n  digestValue?: unknown;\r\n\r\n  // A list of namespace prefixes to be treated as \"inclusive\" during canonicalization.\r\n  inclusiveNamespacesPrefixList: string[];\r\n\r\n  // Optional. Indicates whether the URI is empty.\r\n  isEmptyUri: boolean;\r\n\r\n  // Optional. The type of the reference node.\r\n  ancestorNamespaces?: NamespacePrefix[];\r\n\r\n  validationError?: Error;\r\n\r\n  getValidatedNode(xpathSelector?: string): Node | null;\r\n}\r\n\r\n/** Implement this to create a new CanonicalizationOrTransformationAlgorithm */\r\nexport interface CanonicalizationOrTransformationAlgorithm {\r\n  process(\r\n    node: Node,\r\n    options: CanonicalizationOrTransformationAlgorithmProcessOptions,\r\n  ): Node | string;\r\n\r\n  getAlgorithmName(): CanonicalizationOrTransformAlgorithmType;\r\n}\r\n\r\n/** Implement this to create a new HashAlgorithm */\r\nexport interface HashAlgorithm {\r\n  getAlgorithmName(): HashAlgorithmType;\r\n\r\n  getHash(xml: string): string;\r\n}\r\n\r\n/** Extend this to create a new SignatureAlgorithm */\r\nexport interface SignatureAlgorithm {\r\n  /**\r\n   * Sign the given string using the given key\r\n   */\r\n  getSignature(signedInfo: crypto.BinaryLike, privateKey: crypto.KeyLike): string;\r\n  getSignature(\r\n    signedInfo: crypto.BinaryLike,\r\n    privateKey: crypto.KeyLike,\r\n    callback?: ErrorFirstCallback<string>,\r\n  ): void;\r\n  /**\r\n   * Verify the given signature of the given string using key\r\n   *\r\n   * @param key a public cert, public key, or private key can be passed here\r\n   */\r\n  verifySignature(material: string, key: crypto.KeyLike, signatureValue: string): boolean;\r\n  verifySignature(\r\n    material: string,\r\n    key: crypto.KeyLike,\r\n    signatureValue: string,\r\n    callback?: ErrorFirstCallback<boolean>,\r\n  ): void;\r\n\r\n  getAlgorithmName(): SignatureAlgorithmType;\r\n}\r\n\r\n/** Implement this to create a new TransformAlgorithm */\r\nexport interface TransformAlgorithm {\r\n  getAlgorithmName(): CanonicalizationOrTransformAlgorithmType;\r\n\r\n  process(node: Node): string;\r\n}\r\n\r\n/**\r\n * ### Sign\r\n * #### Properties\r\n * - {@link SignedXml#privateKey} [required]\r\n * - {@link SignedXml#publicCert} [optional]\r\n * - {@link SignedXml#signatureAlgorithm} [optional]\r\n * - {@link SignedXml#canonicalizationAlgorithm} [optional]\r\n * #### Api\r\n *  - {@link SignedXml#addReference}\r\n *  - {@link SignedXml#computeSignature}\r\n *  - {@link SignedXml#getSignedXml}\r\n *  - {@link SignedXml#getSignatureXml}\r\n *  - {@link SignedXml#getOriginalXmlWithIds}\r\n *\r\n * ### Verify\r\n * #### Properties\r\n * -  {@link SignedXml#publicCert} [optional]\r\n * #### Api\r\n *  - {@link SignedXml#loadSignature}\r\n *  - {@link SignedXml#checkSignature}\r\n */\r\n\r\nfunction isErrorFirstCallback<T>(\r\n  possibleCallback: unknown,\r\n): possibleCallback is ErrorFirstCallback<T> {\r\n  return typeof possibleCallback === \"function\";\r\n}\r\n\r\n/**\r\n * This function will add a callback version of a sync function.\r\n *\r\n * This follows the factory pattern.\r\n * Just call this function, passing the function that you'd like to add a callback version of.\r\n */\r\nexport function createOptionalCallbackFunction<T, A extends unknown[]>(\r\n  syncVersion: (...args: A) => T,\r\n): {\r\n  (...args: A): T;\r\n  (...args: [...A, ErrorFirstCallback<T>]): void;\r\n} {\r\n  return ((...args: A | [...A, ErrorFirstCallback<T>]) => {\r\n    const possibleCallback = args[args.length - 1];\r\n    if (isErrorFirstCallback(possibleCallback)) {\r\n      try {\r\n        const result = syncVersion(...(args.slice(0, -1) as A));\r\n        possibleCallback(null, result);\r\n      } catch (err) {\r\n        possibleCallback(err instanceof Error ? err : new Error(\"Unknown error\"));\r\n      }\r\n    } else {\r\n      return syncVersion(...(args as A));\r\n    }\r\n  }) as {\r\n    (...args: A): T;\r\n    (...args: [...A, ErrorFirstCallback<T>]): void;\r\n  };\r\n}\r\n"]}