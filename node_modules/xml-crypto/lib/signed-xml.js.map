{"version":3,"file":"signed-xml.js","sourceRoot":"","sources":["../src/signed-xml.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n  CanonicalizationAlgorithmType,\r\n  CanonicalizationOrTransformationAlgorithm,\r\n  ComputeSignatureOptions,\r\n  GetKeyInfoContentArgs,\r\n  HashAlgorithm,\r\n  HashAlgorithmType,\r\n  Reference,\r\n  SignatureAlgorithm,\r\n  SignatureAlgorithmType,\r\n  SignedXmlOptions,\r\n  CanonicalizationOrTransformAlgorithmType,\r\n  ErrorFirstCallback,\r\n  CanonicalizationOrTransformationAlgorithmProcessOptions,\r\n} from \"./types\";\r\n\r\nimport * as xpath from \"xpath\";\r\nimport * as xmldom from \"@xmldom/xmldom\";\r\nimport * as utils from \"./utils\";\r\nimport * as c14n from \"./c14n-canonicalization\";\r\nimport * as execC14n from \"./exclusive-canonicalization\";\r\nimport * as envelopedSignatures from \"./enveloped-signature\";\r\nimport * as hashAlgorithms from \"./hash-algorithms\";\r\nimport * as signatureAlgorithms from \"./signature-algorithms\";\r\nimport * as crypto from \"crypto\";\r\nimport * as isDomNode from \"@xmldom/is-dom-node\";\r\n\r\nexport class SignedXml {\r\n  idMode?: \"wssecurity\";\r\n  idAttributes: string[];\r\n  /**\r\n   * A {@link Buffer} or pem encoded {@link String} containing your private key\r\n   */\r\n  privateKey?: crypto.KeyLike;\r\n  publicCert?: crypto.KeyLike;\r\n  /**\r\n   * One of the supported signature algorithms.\r\n   * @see {@link SignatureAlgorithmType}\r\n   */\r\n  signatureAlgorithm?: SignatureAlgorithmType = undefined;\r\n  /**\r\n   * Rules used to convert an XML document into its canonical form.\r\n   */\r\n  canonicalizationAlgorithm?: CanonicalizationAlgorithmType = undefined;\r\n  /**\r\n   * It specifies a list of namespace prefixes that should be considered \"inclusive\" during the canonicalization process.\r\n   */\r\n  inclusiveNamespacesPrefixList: string[] = [];\r\n  namespaceResolver: XPathNSResolver = {\r\n    lookupNamespaceURI: function (/* prefix */) {\r\n      throw new Error(\"Not implemented\");\r\n    },\r\n  };\r\n  implicitTransforms: ReadonlyArray<CanonicalizationOrTransformAlgorithmType> = [];\r\n  keyInfoAttributes: { [attrName: string]: string } = {};\r\n  getKeyInfoContent = SignedXml.getKeyInfoContent;\r\n  getCertFromKeyInfo = SignedXml.getCertFromKeyInfo;\r\n\r\n  // Internal state\r\n  private id = 0;\r\n  private signedXml = \"\";\r\n  private signatureXml = \"\";\r\n  private signatureNode: Node | null = null;\r\n  private signatureValue = \"\";\r\n  private originalXmlWithIds = \"\";\r\n  private keyInfo: Node | null = null;\r\n\r\n  /**\r\n   * Contains the references that were signed.\r\n   * @see {@link Reference}\r\n   */\r\n  private references: Reference[] = [];\r\n\r\n  /**\r\n   *  To add a new transformation algorithm create a new class that implements the {@link TransformationAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\r\n   */\r\n  CanonicalizationAlgorithms: Record<\r\n    CanonicalizationOrTransformAlgorithmType,\r\n    new () => CanonicalizationOrTransformationAlgorithm\r\n  > = {\r\n    \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\": c14n.C14nCanonicalization,\r\n    \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\":\r\n      c14n.C14nCanonicalizationWithComments,\r\n    \"http://www.w3.org/2001/10/xml-exc-c14n#\": execC14n.ExclusiveCanonicalization,\r\n    \"http://www.w3.org/2001/10/xml-exc-c14n#WithComments\":\r\n      execC14n.ExclusiveCanonicalizationWithComments,\r\n    \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\": envelopedSignatures.EnvelopedSignature,\r\n  };\r\n\r\n  /**\r\n   * To add a new hash algorithm create a new class that implements the {@link HashAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\r\n   */\r\n  HashAlgorithms: Record<HashAlgorithmType, new () => HashAlgorithm> = {\r\n    \"http://www.w3.org/2000/09/xmldsig#sha1\": hashAlgorithms.Sha1,\r\n    \"http://www.w3.org/2001/04/xmlenc#sha256\": hashAlgorithms.Sha256,\r\n    \"http://www.w3.org/2001/04/xmlenc#sha512\": hashAlgorithms.Sha512,\r\n  };\r\n\r\n  /**\r\n   * To add a new signature algorithm create a new class that implements the {@link SignatureAlgorithm} interface, and register it here. More info: {@link https://github.com/node-saml/xml-crypto#customizing-algorithms|Customizing Algorithms}\r\n   */\r\n  SignatureAlgorithms: Record<SignatureAlgorithmType, new () => SignatureAlgorithm> = {\r\n    \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\": signatureAlgorithms.RsaSha1,\r\n    \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\": signatureAlgorithms.RsaSha256,\r\n    \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha512\": signatureAlgorithms.RsaSha512,\r\n    // Disabled by default due to key confusion concerns.\r\n    // 'http://www.w3.org/2000/09/xmldsig#hmac-sha1': SignatureAlgorithms.HmacSha1\r\n  };\r\n\r\n  static defaultNsForPrefix = {\r\n    ds: \"http://www.w3.org/2000/09/xmldsig#\",\r\n  };\r\n\r\n  static noop = () => null;\r\n\r\n  /**\r\n   * The SignedXml constructor provides an abstraction for sign and verify xml documents. The object is constructed using\r\n   * @param options {@link SignedXmlOptions}\r\n   */\r\n  constructor(options: SignedXmlOptions = {}) {\r\n    const {\r\n      idMode,\r\n      idAttribute,\r\n      privateKey,\r\n      publicCert,\r\n      signatureAlgorithm,\r\n      canonicalizationAlgorithm,\r\n      inclusiveNamespacesPrefixList,\r\n      implicitTransforms,\r\n      keyInfoAttributes,\r\n      getKeyInfoContent,\r\n      getCertFromKeyInfo,\r\n    } = options;\r\n\r\n    // Options\r\n    this.idMode = idMode;\r\n    this.idAttributes = [\"Id\", \"ID\", \"id\"];\r\n    if (idAttribute) {\r\n      this.idAttributes.unshift(idAttribute);\r\n    }\r\n    this.privateKey = privateKey;\r\n    this.publicCert = publicCert;\r\n    this.signatureAlgorithm = signatureAlgorithm ?? this.signatureAlgorithm;\r\n    this.canonicalizationAlgorithm = canonicalizationAlgorithm;\r\n    if (typeof inclusiveNamespacesPrefixList === \"string\") {\r\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList.split(\" \");\r\n    } else if (utils.isArrayHasLength(inclusiveNamespacesPrefixList)) {\r\n      this.inclusiveNamespacesPrefixList = inclusiveNamespacesPrefixList;\r\n    }\r\n    this.implicitTransforms = implicitTransforms ?? this.implicitTransforms;\r\n    this.keyInfoAttributes = keyInfoAttributes ?? this.keyInfoAttributes;\r\n    this.getKeyInfoContent = getKeyInfoContent ?? this.getKeyInfoContent;\r\n    this.getCertFromKeyInfo = getCertFromKeyInfo ?? SignedXml.noop;\r\n    this.CanonicalizationAlgorithms;\r\n    this.HashAlgorithms;\r\n    this.SignatureAlgorithms;\r\n  }\r\n\r\n  /**\r\n   * Due to key-confusion issues, it's risky to have both hmac\r\n   * and digital signature algorithms enabled at the same time.\r\n   * This enables HMAC and disables other signing algorithms.\r\n   */\r\n  enableHMAC(): void {\r\n    this.SignatureAlgorithms = {\r\n      \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\": signatureAlgorithms.HmacSha1,\r\n    };\r\n    this.getKeyInfoContent = SignedXml.noop;\r\n  }\r\n\r\n  /**\r\n   * Builds the contents of a KeyInfo element as an XML string.\r\n   *\r\n   * For example, if the value of the prefix argument is 'foo', then\r\n   * the resultant XML string will be \"<foo:X509Data></foo:X509Data>\"\r\n   *\r\n   * @return an XML string representation of the contents of a KeyInfo element, or `null` if no `KeyInfo` element should be included\r\n   */\r\n  static getKeyInfoContent({ publicCert, prefix }: GetKeyInfoContentArgs): string | null {\r\n    if (publicCert == null) {\r\n      return null;\r\n    }\r\n\r\n    prefix = prefix ? `${prefix}:` : \"\";\r\n\r\n    let x509Certs = \"\";\r\n    if (Buffer.isBuffer(publicCert)) {\r\n      publicCert = publicCert.toString(\"latin1\");\r\n    }\r\n\r\n    let publicCertMatches: string[] = [];\r\n    if (typeof publicCert === \"string\") {\r\n      publicCertMatches = publicCert.match(utils.EXTRACT_X509_CERTS) || [];\r\n    }\r\n\r\n    if (publicCertMatches.length > 0) {\r\n      x509Certs = publicCertMatches\r\n        .map(\r\n          (c) =>\r\n            `<${prefix}X509Certificate>${utils\r\n              .pemToDer(c)\r\n              .toString(\"base64\")}</${prefix}X509Certificate>`,\r\n        )\r\n        .join(\"\");\r\n    }\r\n\r\n    return `<${prefix}X509Data>${x509Certs}</${prefix}X509Data>`;\r\n  }\r\n\r\n  /**\r\n   * Returns the value of the signing certificate based on the contents of the\r\n   * specified KeyInfo.\r\n   *\r\n   * @param keyInfo KeyInfo element (@see https://www.w3.org/TR/2008/REC-xmldsig-core-20080610/#sec-X509Data)\r\n   * @return the signing certificate as a string in PEM format\r\n   */\r\n  static getCertFromKeyInfo(keyInfo?: Node | null): string | null {\r\n    if (keyInfo != null) {\r\n      const cert = xpath.select1(\".//*[local-name(.)='X509Certificate']\", keyInfo);\r\n      if (isDomNode.isNodeLike(cert)) {\r\n        return utils.derToPem(cert.textContent ?? \"\", \"CERTIFICATE\");\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Validates the signature of the provided XML document synchronously using the configured key info provider.\r\n   *\r\n   * @param xml The XML document containing the signature to be validated.\r\n   * @returns `true` if the signature is valid\r\n   * @throws Error if no key info resolver is provided.\r\n   */\r\n  checkSignature(xml: string): boolean;\r\n  /**\r\n   * Validates the signature of the provided XML document synchronously using the configured key info provider.\r\n   *\r\n   * @param xml The XML document containing the signature to be validated.\r\n   * @param callback Callback function to handle the validation result asynchronously.\r\n   * @throws Error if the last parameter is provided and is not a function, or if no key info resolver is provided.\r\n   */\r\n  checkSignature(xml: string, callback: (error: Error | null, isValid?: boolean) => void): void;\r\n  checkSignature(\r\n    xml: string,\r\n    callback?: (error: Error | null, isValid?: boolean) => void,\r\n  ): unknown {\r\n    if (callback != null && typeof callback !== \"function\") {\r\n      throw new Error(\"Last parameter must be a callback function\");\r\n    }\r\n\r\n    this.signedXml = xml;\r\n\r\n    const doc = new xmldom.DOMParser().parseFromString(xml);\r\n    // Reset the references as only references from our re-parsed signedInfo node can be trusted\r\n    this.references = [];\r\n\r\n    const unverifiedSignedInfoCanon = this.getCanonSignedInfoXml(doc);\r\n    if (!unverifiedSignedInfoCanon) {\r\n      if (callback) {\r\n        callback(new Error(\"Canonical signed info cannot be empty\"), false);\r\n        return;\r\n      }\r\n\r\n      throw new Error(\"Canonical signed info cannot be empty\");\r\n    }\r\n\r\n    // unsigned, verify later to keep with consistent callback behavior\r\n    const parsedUnverifiedSignedInfo = new xmldom.DOMParser().parseFromString(\r\n      unverifiedSignedInfoCanon,\r\n      \"text/xml\",\r\n    );\r\n\r\n    const unverifiedSignedInfoDoc = parsedUnverifiedSignedInfo.documentElement;\r\n    if (!unverifiedSignedInfoDoc) {\r\n      if (callback) {\r\n        callback(new Error(\"Could not parse unverifiedSignedInfoCanon into a document\"), false);\r\n        return;\r\n      }\r\n\r\n      throw new Error(\"Could not parse unverifiedSignedInfoCanon into a document\");\r\n    }\r\n\r\n    const references = utils.findChildren(unverifiedSignedInfoDoc, \"Reference\");\r\n    if (!utils.isArrayHasLength(references)) {\r\n      if (callback) {\r\n        callback(new Error(\"could not find any Reference elements\"), false);\r\n        return;\r\n      }\r\n\r\n      throw new Error(\"could not find any Reference elements\");\r\n    }\r\n\r\n    // TODO: In a future release we'd like to load the Signature and its References at the same time,\r\n    // however, in the `.loadSignature()` method we don't have the entire document,\r\n    // which we need to to keep the inclusive namespaces\r\n    for (const reference of references) {\r\n      this.loadReference(reference);\r\n    }\r\n\r\n    if (!this.getReferences().every((ref) => this.validateReference(ref, doc))) {\r\n      if (callback) {\r\n        callback(new Error(\"Could not validate all references\"), false);\r\n        return;\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    // Stage B: Take the signature algorithm and key and verify the SignatureValue against the canonicalized SignedInfo\r\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\r\n    const key = this.getCertFromKeyInfo(this.keyInfo) || this.publicCert || this.privateKey;\r\n    if (key == null) {\r\n      throw new Error(\"KeyInfo or publicCert or privateKey is required to validate signature\");\r\n    }\r\n\r\n    if (callback) {\r\n      signer.verifySignature(unverifiedSignedInfoCanon, key, this.signatureValue, callback);\r\n    } else {\r\n      const verified = signer.verifySignature(unverifiedSignedInfoCanon, key, this.signatureValue);\r\n\r\n      if (verified === false) {\r\n        throw new Error(\r\n          `invalid signature: the signature value ${this.signatureValue} is incorrect`,\r\n        );\r\n      }\r\n\r\n      return true;\r\n    }\r\n  }\r\n\r\n  private getCanonSignedInfoXml(doc: Document) {\r\n    if (this.signatureNode == null) {\r\n      throw new Error(\"No signature found.\");\r\n    }\r\n    if (typeof this.canonicalizationAlgorithm !== \"string\") {\r\n      throw new Error(\"Missing canonicalizationAlgorithm when trying to get signed info for XML\");\r\n    }\r\n\r\n    const signedInfo = utils.findChildren(this.signatureNode, \"SignedInfo\");\r\n    if (signedInfo.length === 0) {\r\n      throw new Error(\"could not find SignedInfo element in the message\");\r\n    }\r\n    if (signedInfo.length > 1) {\r\n      throw new Error(\r\n        \"could not get canonicalized signed info for a signature that contains multiple SignedInfo nodes\",\r\n      );\r\n    }\r\n\r\n    if (\r\n      this.canonicalizationAlgorithm === \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" ||\r\n      this.canonicalizationAlgorithm ===\r\n        \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\"\r\n    ) {\r\n      if (!doc || typeof doc !== \"object\") {\r\n        throw new Error(\r\n          \"When canonicalization method is non-exclusive, whole xml dom must be provided as an argument\",\r\n        );\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Search for ancestor namespaces before canonicalization.\r\n     */\r\n    const ancestorNamespaces = utils.findAncestorNs(doc, \"//*[local-name()='SignedInfo']\");\r\n\r\n    const c14nOptions = {\r\n      ancestorNamespaces: ancestorNamespaces,\r\n    };\r\n\r\n    return this.getCanonXml([this.canonicalizationAlgorithm], signedInfo[0], c14nOptions);\r\n  }\r\n\r\n  private getCanonReferenceXml(doc: Document, ref: Reference, node: Node) {\r\n    /**\r\n     * Search for ancestor namespaces before canonicalization.\r\n     */\r\n    if (Array.isArray(ref.transforms)) {\r\n      ref.ancestorNamespaces = utils.findAncestorNs(doc, ref.xpath, this.namespaceResolver);\r\n    }\r\n\r\n    const c14nOptions = {\r\n      inclusiveNamespacesPrefixList: ref.inclusiveNamespacesPrefixList,\r\n      ancestorNamespaces: ref.ancestorNamespaces,\r\n    };\r\n\r\n    return this.getCanonXml(ref.transforms, node, c14nOptions);\r\n  }\r\n\r\n  private calculateSignatureValue(doc: Document, callback?: ErrorFirstCallback<string>) {\r\n    const signedInfoCanon = this.getCanonSignedInfoXml(doc);\r\n    const signer = this.findSignatureAlgorithm(this.signatureAlgorithm);\r\n    if (this.privateKey == null) {\r\n      throw new Error(\"Private key is required to compute signature\");\r\n    }\r\n    if (typeof callback === \"function\") {\r\n      signer.getSignature(signedInfoCanon, this.privateKey, callback);\r\n    } else {\r\n      this.signatureValue = signer.getSignature(signedInfoCanon, this.privateKey);\r\n    }\r\n  }\r\n\r\n  private findSignatureAlgorithm(name?: SignatureAlgorithmType) {\r\n    if (name == null) {\r\n      throw new Error(\"signatureAlgorithm is required\");\r\n    }\r\n    const algo = this.SignatureAlgorithms[name];\r\n    if (algo) {\r\n      return new algo();\r\n    } else {\r\n      throw new Error(`signature algorithm '${name}' is not supported`);\r\n    }\r\n  }\r\n\r\n  private findCanonicalizationAlgorithm(name: CanonicalizationOrTransformAlgorithmType) {\r\n    if (name != null) {\r\n      const algo = this.CanonicalizationAlgorithms[name];\r\n      if (algo) {\r\n        return new algo();\r\n      }\r\n    }\r\n\r\n    throw new Error(`canonicalization algorithm '${name}' is not supported`);\r\n  }\r\n\r\n  private findHashAlgorithm(name: HashAlgorithmType) {\r\n    const algo = this.HashAlgorithms[name];\r\n    if (algo) {\r\n      return new algo();\r\n    } else {\r\n      throw new Error(`hash algorithm '${name}' is not supported`);\r\n    }\r\n  }\r\n\r\n  validateElementAgainstReferences(elemOrXpath: Element | string, doc: Document): Reference {\r\n    let elem: Element;\r\n    if (typeof elemOrXpath === \"string\") {\r\n      const firstElem = xpath.select1(elemOrXpath, doc);\r\n      isDomNode.assertIsElementNode(firstElem);\r\n      elem = firstElem;\r\n    } else {\r\n      elem = elemOrXpath;\r\n    }\r\n\r\n    for (const ref of this.getReferences()) {\r\n      const uri = ref.uri?.[0] === \"#\" ? ref.uri.substring(1) : ref.uri;\r\n\r\n      for (const attr of this.idAttributes) {\r\n        const elemId = elem.getAttribute(attr);\r\n        if (uri === elemId) {\r\n          ref.xpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;\r\n          break; // found the correct element, no need to check further\r\n        }\r\n      }\r\n\r\n      const canonXml = this.getCanonReferenceXml(doc, ref, elem);\r\n      const hash = this.findHashAlgorithm(ref.digestAlgorithm);\r\n      const digest = hash.getHash(canonXml);\r\n\r\n      if (utils.validateDigestValue(digest, ref.digestValue)) {\r\n        return ref;\r\n      }\r\n    }\r\n\r\n    throw new Error(\"No references passed validation\");\r\n  }\r\n\r\n  private validateReference(ref: Reference, doc: Document) {\r\n    const uri = ref.uri?.[0] === \"#\" ? ref.uri.substring(1) : ref.uri;\r\n    let elem: xpath.SelectSingleReturnType = null;\r\n\r\n    if (uri === \"\") {\r\n      elem = xpath.select1(\"//*\", doc);\r\n    } else if (uri?.indexOf(\"'\") !== -1) {\r\n      // xpath injection\r\n      throw new Error(\"Cannot validate a uri with quotes inside it\");\r\n    } else {\r\n      let num_elements_for_id = 0;\r\n      for (const attr of this.idAttributes) {\r\n        const tmp_elemXpath = `//*[@*[local-name(.)='${attr}']='${uri}']`;\r\n        const tmp_elem = xpath.select(tmp_elemXpath, doc);\r\n        if (utils.isArrayHasLength(tmp_elem)) {\r\n          num_elements_for_id += tmp_elem.length;\r\n\r\n          if (num_elements_for_id > 1) {\r\n            throw new Error(\r\n              \"Cannot validate a document which contains multiple elements with the \" +\r\n                \"same value for the ID / Id / Id attributes, in order to prevent \" +\r\n                \"signature wrapping attack.\",\r\n            );\r\n          }\r\n\r\n          elem = tmp_elem[0];\r\n          ref.xpath = tmp_elemXpath;\r\n        }\r\n      }\r\n    }\r\n\r\n    ref.getValidatedNode = (xpathSelector?: string) => {\r\n      xpathSelector = xpathSelector || ref.xpath;\r\n      if (typeof xpathSelector !== \"string\" || ref.validationError != null) {\r\n        return null;\r\n      }\r\n      const selectedValue = xpath.select1(xpathSelector, doc);\r\n      return isDomNode.isNodeLike(selectedValue) ? selectedValue : null;\r\n    };\r\n\r\n    if (!isDomNode.isNodeLike(elem)) {\r\n      const validationError = new Error(\r\n        `invalid signature: the signature references an element with uri ${ref.uri} but could not find such element in the xml`,\r\n      );\r\n      ref.validationError = validationError;\r\n      return false;\r\n    }\r\n\r\n    const canonXml = this.getCanonReferenceXml(doc, ref, elem);\r\n    const hash = this.findHashAlgorithm(ref.digestAlgorithm);\r\n    const digest = hash.getHash(canonXml);\r\n\r\n    if (!utils.validateDigestValue(digest, ref.digestValue)) {\r\n      const validationError = new Error(\r\n        `invalid signature: for uri ${ref.uri} calculated digest is ${digest} but the xml to validate supplies digest ${ref.digestValue}`,\r\n      );\r\n      ref.validationError = validationError;\r\n\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  findSignatures(doc: Node): Node[] {\r\n    const nodes = xpath.select(\r\n      \"//*[local-name(.)='Signature' and namespace-uri(.)='http://www.w3.org/2000/09/xmldsig#']\",\r\n      doc,\r\n    );\r\n\r\n    return isDomNode.isArrayOfNodes(nodes) ? nodes : [];\r\n  }\r\n\r\n  /**\r\n   * Loads the signature information from the provided XML node or string.\r\n   *\r\n   * @param signatureNode The XML node or string representing the signature.\r\n   */\r\n  loadSignature(signatureNode: Node | string): void {\r\n    if (typeof signatureNode === \"string\") {\r\n      this.signatureNode = signatureNode = new xmldom.DOMParser().parseFromString(signatureNode);\r\n    } else {\r\n      this.signatureNode = signatureNode;\r\n    }\r\n\r\n    this.signatureXml = signatureNode.toString();\r\n\r\n    const node = xpath.select1(\r\n      \".//*[local-name(.)='CanonicalizationMethod']/@Algorithm\",\r\n      signatureNode,\r\n    );\r\n    if (!isDomNode.isNodeLike(node)) {\r\n      throw new Error(\"could not find CanonicalizationMethod/@Algorithm element\");\r\n    }\r\n\r\n    if (isDomNode.isAttributeNode(node)) {\r\n      this.canonicalizationAlgorithm = node.value as CanonicalizationAlgorithmType;\r\n    }\r\n\r\n    const signatureAlgorithm = xpath.select1(\r\n      \".//*[local-name(.)='SignatureMethod']/@Algorithm\",\r\n      signatureNode,\r\n    );\r\n\r\n    if (isDomNode.isAttributeNode(signatureAlgorithm)) {\r\n      this.signatureAlgorithm = signatureAlgorithm.value as SignatureAlgorithmType;\r\n    }\r\n\r\n    const signedInfoNodes = utils.findChildren(this.signatureNode, \"SignedInfo\");\r\n    if (!utils.isArrayHasLength(signedInfoNodes)) {\r\n      throw new Error(\"no signed info node found\");\r\n    }\r\n    if (signedInfoNodes.length > 1) {\r\n      throw new Error(\"could not load signature that contains multiple SignedInfo nodes\");\r\n    }\r\n\r\n    // Try to operate on the c14n version of `signedInfo`. This forces the initial `getReferences()`\r\n    // API call to always return references that are loaded under the canonical `SignedInfo`\r\n    // in the case that the client access the `.references` **before** signature verification.\r\n\r\n    // Ensure canonicalization algorithm is exclusive, otherwise we'd need the entire document\r\n    let canonicalizationAlgorithmForSignedInfo = this.canonicalizationAlgorithm;\r\n    if (\r\n      !canonicalizationAlgorithmForSignedInfo ||\r\n      canonicalizationAlgorithmForSignedInfo ===\r\n        \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\" ||\r\n      canonicalizationAlgorithmForSignedInfo ===\r\n        \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\"\r\n    ) {\r\n      canonicalizationAlgorithmForSignedInfo = \"http://www.w3.org/2001/10/xml-exc-c14n#\";\r\n    }\r\n\r\n    const temporaryCanonSignedInfo = this.getCanonXml(\r\n      [canonicalizationAlgorithmForSignedInfo],\r\n      signedInfoNodes[0],\r\n    );\r\n    const temporaryCanonSignedInfoXml = new xmldom.DOMParser().parseFromString(\r\n      temporaryCanonSignedInfo,\r\n      \"text/xml\",\r\n    );\r\n    const signedInfoDoc = temporaryCanonSignedInfoXml.documentElement;\r\n\r\n    this.references = [];\r\n    const references = utils.findChildren(signedInfoDoc, \"Reference\");\r\n\r\n    if (!utils.isArrayHasLength(references)) {\r\n      throw new Error(\"could not find any Reference elements\");\r\n    }\r\n\r\n    for (const reference of references) {\r\n      this.loadReference(reference);\r\n    }\r\n\r\n    const signatureValue = xpath.select1(\r\n      \".//*[local-name(.)='SignatureValue']/text()\",\r\n      signatureNode,\r\n    );\r\n\r\n    if (isDomNode.isTextNode(signatureValue)) {\r\n      this.signatureValue = signatureValue.data.replace(/\\r?\\n/g, \"\");\r\n    }\r\n\r\n    const keyInfo = xpath.select1(\".//*[local-name(.)='KeyInfo']\", signatureNode);\r\n\r\n    if (isDomNode.isNodeLike(keyInfo)) {\r\n      this.keyInfo = keyInfo;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load the reference xml node to a model\r\n   *\r\n   */\r\n  private loadReference(refNode: Node) {\r\n    let nodes = utils.findChildren(refNode, \"DigestMethod\");\r\n    if (nodes.length === 0) {\r\n      throw new Error(`could not find DigestMethod in reference ${refNode.toString()}`);\r\n    }\r\n    const digestAlgoNode = nodes[0];\r\n\r\n    const attr = utils.findAttr(digestAlgoNode, \"Algorithm\");\r\n    if (!attr) {\r\n      throw new Error(`could not find Algorithm attribute in node ${digestAlgoNode.toString()}`);\r\n    }\r\n    const digestAlgo = attr.value;\r\n\r\n    nodes = utils.findChildren(refNode, \"DigestValue\");\r\n    if (nodes.length === 0) {\r\n      throw new Error(`could not find DigestValue node in reference ${refNode.toString()}`);\r\n    }\r\n    if (nodes.length > 1) {\r\n      throw new Error(\r\n        `could not load reference for a node that contains multiple DigestValue nodes: ${refNode.toString()}`,\r\n      );\r\n    }\r\n    const digestValue = nodes[0].textContent;\r\n    if (!digestValue) {\r\n      throw new Error(`could not find the value of DigestValue in ${refNode.toString()}`);\r\n    }\r\n\r\n    const transforms: string[] = [];\r\n    let inclusiveNamespacesPrefixList: string[] = [];\r\n    nodes = utils.findChildren(refNode, \"Transforms\");\r\n    if (nodes.length !== 0) {\r\n      const transformsNode = nodes[0];\r\n      const transformsAll = utils.findChildren(transformsNode, \"Transform\");\r\n      for (const transform of transformsAll) {\r\n        const transformAttr = utils.findAttr(transform, \"Algorithm\");\r\n\r\n        if (transformAttr) {\r\n          transforms.push(transformAttr.value);\r\n        }\r\n      }\r\n\r\n      // This is a little strange, we are looking for children of the last child of `transformsNode`\r\n      const inclusiveNamespaces = utils.findChildren(\r\n        transformsAll[transformsAll.length - 1],\r\n        \"InclusiveNamespaces\",\r\n      );\r\n      if (utils.isArrayHasLength(inclusiveNamespaces)) {\r\n        // Should really only be one prefix list, but maybe there's some circumstances where more than one to let's handle it\r\n        inclusiveNamespacesPrefixList = inclusiveNamespaces\r\n          .flatMap((namespace) => (namespace.getAttribute(\"PrefixList\") ?? \"\").split(\" \"))\r\n          .filter((value) => value.length > 0);\r\n      }\r\n    }\r\n\r\n    if (utils.isArrayHasLength(this.implicitTransforms)) {\r\n      this.implicitTransforms.forEach(function (t) {\r\n        transforms.push(t);\r\n      });\r\n    }\r\n\r\n    /**\r\n     * DigestMethods take an octet stream rather than a node set. If the output of the last transform is a node set, we\r\n     * need to canonicalize the node set to an octet stream using non-exclusive canonicalization. If there are no\r\n     * transforms, we need to canonicalize because URI dereferencing for a same-document reference will return a node-set.\r\n     * @see:\r\n     * https://www.w3.org/TR/xmldsig-core1/#sec-DigestMethod\r\n     * https://www.w3.org/TR/xmldsig-core1/#sec-ReferenceProcessingModel\r\n     * https://www.w3.org/TR/xmldsig-core1/#sec-Same-Document\r\n     */\r\n    if (\r\n      transforms.length === 0 ||\r\n      transforms[transforms.length - 1] === \"http://www.w3.org/2000/09/xmldsig#enveloped-signature\"\r\n    ) {\r\n      transforms.push(\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\");\r\n    }\r\n    const refUri = isDomNode.isElementNode(refNode)\r\n      ? refNode.getAttribute(\"URI\") || undefined\r\n      : undefined;\r\n\r\n    this.addReference({\r\n      transforms,\r\n      digestAlgorithm: digestAlgo,\r\n      uri: refUri,\r\n      digestValue,\r\n      inclusiveNamespacesPrefixList,\r\n      isEmptyUri: false,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds a reference to the signature.\r\n   *\r\n   * @param xpath The XPath expression to select the XML nodes to be referenced.\r\n   * @param transforms An array of transform algorithms to be applied to the selected nodes.\r\n   * @param digestAlgorithm The digest algorithm to use for computing the digest value.\r\n   * @param uri The URI identifier for the reference. If empty, an empty URI will be used.\r\n   * @param digestValue The expected digest value for the reference.\r\n   * @param inclusiveNamespacesPrefixList The prefix list for inclusive namespace canonicalization.\r\n   * @param isEmptyUri Indicates whether the URI is empty. Defaults to `false`.\r\n   */\r\n  addReference({\r\n    xpath,\r\n    transforms,\r\n    digestAlgorithm,\r\n    uri = \"\",\r\n    digestValue,\r\n    inclusiveNamespacesPrefixList = [],\r\n    isEmptyUri = false,\r\n  }: Partial<Reference> & Pick<Reference, \"xpath\">): void {\r\n    if (digestAlgorithm == null) {\r\n      throw new Error(\"digestAlgorithm is required\");\r\n    }\r\n\r\n    if (!utils.isArrayHasLength(transforms)) {\r\n      throw new Error(\"transforms must contain at least one transform algorithm\");\r\n    }\r\n\r\n    this.references.push({\r\n      xpath,\r\n      transforms,\r\n      digestAlgorithm,\r\n      uri,\r\n      digestValue,\r\n      inclusiveNamespacesPrefixList,\r\n      isEmptyUri,\r\n      getValidatedNode: () => {\r\n        throw new Error(\r\n          \"Reference has not been validated yet; Did you call `sig.checkSignature()`?\",\r\n        );\r\n      },\r\n    });\r\n  }\r\n\r\n  getReferences(): Reference[] {\r\n    return this.references;\r\n  }\r\n\r\n  /**\r\n   * Compute the signature of the given XML (using the already defined settings).\r\n   *\r\n   * @param xml The XML to compute the signature for.\r\n   * @param callback A callback function to handle the signature computation asynchronously.\r\n   * @returns void\r\n   * @throws TypeError If the xml can not be parsed.\r\n   */\r\n  computeSignature(xml: string): void;\r\n\r\n  /**\r\n   * Compute the signature of the given XML (using the already defined settings).\r\n   *\r\n   * @param xml The XML to compute the signature for.\r\n   * @param callback A callback function to handle the signature computation asynchronously.\r\n   * @returns void\r\n   * @throws TypeError If the xml can not be parsed.\r\n   */\r\n  computeSignature(xml: string, callback: ErrorFirstCallback<SignedXml>): void;\r\n\r\n  /**\r\n   * Compute the signature of the given XML (using the already defined settings).\r\n   *\r\n   * @param xml The XML to compute the signature for.\r\n   * @param opts An object containing options for the signature computation.\r\n   * @returns If no callback is provided, returns `this` (the instance of SignedXml).\r\n   * @throws TypeError If the xml can not be parsed, or Error if there were invalid options passed.\r\n   */\r\n  computeSignature(xml: string, options: ComputeSignatureOptions): void;\r\n\r\n  /**\r\n   * Compute the signature of the given XML (using the already defined settings).\r\n   *\r\n   * @param xml The XML to compute the signature for.\r\n   * @param opts An object containing options for the signature computation.\r\n   * @param callback A callback function to handle the signature computation asynchronously.\r\n   * @returns void\r\n   * @throws TypeError If the xml can not be parsed, or Error if there were invalid options passed.\r\n   */\r\n  computeSignature(\r\n    xml: string,\r\n    options: ComputeSignatureOptions,\r\n    callback: ErrorFirstCallback<SignedXml>,\r\n  ): void;\r\n\r\n  computeSignature(\r\n    xml: string,\r\n    options?: ComputeSignatureOptions | ErrorFirstCallback<SignedXml>,\r\n    callbackParam?: ErrorFirstCallback<SignedXml>,\r\n  ): void {\r\n    let callback: ErrorFirstCallback<SignedXml>;\r\n    if (typeof options === \"function\" && callbackParam == null) {\r\n      callback = options as ErrorFirstCallback<SignedXml>;\r\n      options = {} as ComputeSignatureOptions;\r\n    } else {\r\n      callback = callbackParam as ErrorFirstCallback<SignedXml>;\r\n      options = (options ?? {}) as ComputeSignatureOptions;\r\n    }\r\n\r\n    const doc = new xmldom.DOMParser().parseFromString(xml);\r\n    let xmlNsAttr = \"xmlns\";\r\n    const signatureAttrs: string[] = [];\r\n    let currentPrefix: string;\r\n\r\n    const validActions = [\"append\", \"prepend\", \"before\", \"after\"];\r\n\r\n    const prefix = options.prefix;\r\n    const attrs = options.attrs || {};\r\n    const location = options.location || {};\r\n    const existingPrefixes = options.existingPrefixes || {};\r\n\r\n    this.namespaceResolver = {\r\n      lookupNamespaceURI: function (prefix) {\r\n        return prefix ? existingPrefixes[prefix] : null;\r\n      },\r\n    };\r\n\r\n    // defaults to the root node\r\n    location.reference = location.reference || \"/*\";\r\n    // defaults to append action\r\n    location.action = location.action || \"append\";\r\n\r\n    if (validActions.indexOf(location.action) === -1) {\r\n      const err = new Error(\r\n        `location.action option has an invalid action: ${\r\n          location.action\r\n        }, must be any of the following values: ${validActions.join(\", \")}`,\r\n      );\r\n      if (!callback) {\r\n        throw err;\r\n      } else {\r\n        callback(err);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // automatic insertion of `:`\r\n    if (prefix) {\r\n      xmlNsAttr += `:${prefix}`;\r\n      currentPrefix = `${prefix}:`;\r\n    } else {\r\n      currentPrefix = \"\";\r\n    }\r\n\r\n    Object.keys(attrs).forEach(function (name) {\r\n      if (name !== \"xmlns\" && name !== xmlNsAttr) {\r\n        signatureAttrs.push(`${name}=\"${attrs[name]}\"`);\r\n      }\r\n    });\r\n\r\n    // add the xml namespace attribute\r\n    signatureAttrs.push(`${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\"`);\r\n\r\n    let signatureXml = `<${currentPrefix}Signature ${signatureAttrs.join(\" \")}>`;\r\n\r\n    signatureXml += this.createSignedInfo(doc, prefix);\r\n    signatureXml += this.getKeyInfo(prefix);\r\n    signatureXml += `</${currentPrefix}Signature>`;\r\n\r\n    this.originalXmlWithIds = doc.toString();\r\n\r\n    let existingPrefixesString = \"\";\r\n    Object.keys(existingPrefixes).forEach(function (key) {\r\n      existingPrefixesString += `xmlns:${key}=\"${existingPrefixes[key]}\" `;\r\n    });\r\n\r\n    // A trick to remove the namespaces that already exist in the xml\r\n    // This only works if the prefix and namespace match with those in the xml\r\n    const dummySignatureWrapper = `<Dummy ${existingPrefixesString}>${signatureXml}</Dummy>`;\r\n    const nodeXml = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\r\n\r\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    const signatureDoc = nodeXml.documentElement.firstChild!;\r\n\r\n    const referenceNode = xpath.select1(location.reference, doc);\r\n\r\n    if (!isDomNode.isNodeLike(referenceNode)) {\r\n      const err2 = new Error(\r\n        `the following xpath cannot be used because it was not found: ${location.reference}`,\r\n      );\r\n      if (!callback) {\r\n        throw err2;\r\n      } else {\r\n        callback(err2);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (location.action === \"append\") {\r\n      referenceNode.appendChild(signatureDoc);\r\n    } else if (location.action === \"prepend\") {\r\n      referenceNode.insertBefore(signatureDoc, referenceNode.firstChild);\r\n    } else if (location.action === \"before\") {\r\n      if (referenceNode.parentNode == null) {\r\n        throw new Error(\r\n          \"`location.reference` refers to the root node (by default), so we can't insert `before`\",\r\n        );\r\n      }\r\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode);\r\n    } else if (location.action === \"after\") {\r\n      if (referenceNode.parentNode == null) {\r\n        throw new Error(\r\n          \"`location.reference` refers to the root node (by default), so we can't insert `after`\",\r\n        );\r\n      }\r\n      referenceNode.parentNode.insertBefore(signatureDoc, referenceNode.nextSibling);\r\n    }\r\n\r\n    this.signatureNode = signatureDoc;\r\n    const signedInfoNodes = utils.findChildren(this.signatureNode, \"SignedInfo\");\r\n    if (signedInfoNodes.length === 0) {\r\n      const err3 = new Error(\"could not find SignedInfo element in the message\");\r\n      if (!callback) {\r\n        throw err3;\r\n      } else {\r\n        callback(err3);\r\n        return;\r\n      }\r\n    }\r\n    const signedInfoNode = signedInfoNodes[0];\r\n\r\n    if (typeof callback === \"function\") {\r\n      // Asynchronous flow\r\n      this.calculateSignatureValue(doc, (err, signature) => {\r\n        if (err) {\r\n          callback(err);\r\n        } else {\r\n          this.signatureValue = signature || \"\";\r\n          signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\r\n          this.signatureXml = signatureDoc.toString();\r\n          this.signedXml = doc.toString();\r\n          callback(null, this);\r\n        }\r\n      });\r\n    } else {\r\n      // Synchronous flow\r\n      this.calculateSignatureValue(doc);\r\n      signatureDoc.insertBefore(this.createSignature(prefix), signedInfoNode.nextSibling);\r\n      this.signatureXml = signatureDoc.toString();\r\n      this.signedXml = doc.toString();\r\n    }\r\n  }\r\n\r\n  private getKeyInfo(prefix) {\r\n    const currentPrefix = prefix ? `${prefix}:` : \"\";\r\n\r\n    let keyInfoAttrs = \"\";\r\n    if (this.keyInfoAttributes) {\r\n      Object.keys(this.keyInfoAttributes).forEach((name) => {\r\n        keyInfoAttrs += ` ${name}=\"${this.keyInfoAttributes[name]}\"`;\r\n      });\r\n    }\r\n\r\n    const keyInfoContent = this.getKeyInfoContent({ publicCert: this.publicCert, prefix });\r\n    if (keyInfoAttrs || keyInfoContent) {\r\n      return `<${currentPrefix}KeyInfo${keyInfoAttrs}>${keyInfoContent}</${currentPrefix}KeyInfo>`;\r\n    }\r\n\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Generate the Reference nodes (as part of the signature process)\r\n   *\r\n   */\r\n  private createReferences(doc, prefix) {\r\n    let res = \"\";\r\n\r\n    prefix = prefix || \"\";\r\n    prefix = prefix ? `${prefix}:` : prefix;\r\n\r\n    for (const ref of this.getReferences()) {\r\n      const nodes = xpath.selectWithResolver(ref.xpath ?? \"\", doc, this.namespaceResolver);\r\n\r\n      if (!utils.isArrayHasLength(nodes)) {\r\n        throw new Error(\r\n          `the following xpath cannot be signed because it was not found: ${ref.xpath}`,\r\n        );\r\n      }\r\n\r\n      for (const node of nodes) {\r\n        if (ref.isEmptyUri) {\r\n          res += `<${prefix}Reference URI=\"\">`;\r\n        } else {\r\n          const id = this.ensureHasId(node);\r\n          ref.uri = id;\r\n          res += `<${prefix}Reference URI=\"#${id}\">`;\r\n        }\r\n        res += `<${prefix}Transforms>`;\r\n        for (const trans of ref.transforms || []) {\r\n          const transform = this.findCanonicalizationAlgorithm(trans);\r\n          res += `<${prefix}Transform Algorithm=\"${transform.getAlgorithmName()}\"`;\r\n          if (utils.isArrayHasLength(ref.inclusiveNamespacesPrefixList)) {\r\n            res += \">\";\r\n            res += `<InclusiveNamespaces PrefixList=\"${ref.inclusiveNamespacesPrefixList.join(\r\n              \" \",\r\n            )}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\r\n            res += `</${prefix}Transform>`;\r\n          } else {\r\n            res += \" />\";\r\n          }\r\n        }\r\n\r\n        const canonXml = this.getCanonReferenceXml(doc, ref, node);\r\n\r\n        const digestAlgorithm = this.findHashAlgorithm(ref.digestAlgorithm);\r\n        res +=\r\n          `</${prefix}Transforms>` +\r\n          `<${prefix}DigestMethod Algorithm=\"${digestAlgorithm.getAlgorithmName()}\" />` +\r\n          `<${prefix}DigestValue>${digestAlgorithm.getHash(canonXml)}</${prefix}DigestValue>` +\r\n          `</${prefix}Reference>`;\r\n      }\r\n    }\r\n\r\n    return res;\r\n  }\r\n\r\n  getCanonXml(\r\n    transforms: Reference[\"transforms\"],\r\n    node: Node,\r\n    options: CanonicalizationOrTransformationAlgorithmProcessOptions = {},\r\n  ) {\r\n    options.defaultNsForPrefix = options.defaultNsForPrefix ?? SignedXml.defaultNsForPrefix;\r\n    options.signatureNode = this.signatureNode;\r\n\r\n    const canonXml = node.cloneNode(true); // Deep clone\r\n    let transformedXml: Node | string = canonXml;\r\n\r\n    transforms.forEach((transformName) => {\r\n      if (isDomNode.isNodeLike(transformedXml)) {\r\n        // If, after processing, `transformedNode` is a string, we can't do anymore transforms on it\r\n        const transform = this.findCanonicalizationAlgorithm(transformName);\r\n        transformedXml = transform.process(transformedXml, options);\r\n      }\r\n      //TODO: currently transform.process may return either Node or String value (enveloped transformation returns Node, exclusive-canonicalization returns String).\r\n      //This either needs to be more explicit in the API, or all should return the same.\r\n      //exclusive-canonicalization returns String since it builds the Xml by hand. If it had used xmldom it would incorrectly minimize empty tags\r\n      //to <x/> instead of <x></x> and also incorrectly handle some delicate line break issues.\r\n      //enveloped transformation returns Node since if it would return String consider this case:\r\n      //<x xmlns:p='ns'><p:y/></x>\r\n      //if only y is the node to sign then a string would be <p:y/> without the definition of the p namespace. probably xmldom toString() should have added it.\r\n    });\r\n\r\n    return transformedXml.toString();\r\n  }\r\n\r\n  /**\r\n   * Ensure an element has Id attribute. If not create it with unique value.\r\n   * Work with both normal and wssecurity Id flavour\r\n   */\r\n  private ensureHasId(node) {\r\n    let attr;\r\n\r\n    if (this.idMode === \"wssecurity\") {\r\n      attr = utils.findAttr(\r\n        node,\r\n        \"Id\",\r\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\r\n      );\r\n    } else {\r\n      this.idAttributes.some((idAttribute) => {\r\n        attr = utils.findAttr(node, idAttribute);\r\n        return !!attr; // This will break the loop as soon as a truthy attr is found.\r\n      });\r\n    }\r\n\r\n    if (attr) {\r\n      return attr.value;\r\n    }\r\n\r\n    //add the attribute\r\n    const id = `_${this.id++}`;\r\n\r\n    if (this.idMode === \"wssecurity\") {\r\n      node.setAttributeNS(\r\n        \"http://www.w3.org/2000/xmlns/\",\r\n        \"xmlns:wsu\",\r\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\r\n      );\r\n      node.setAttributeNS(\r\n        \"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\",\r\n        \"wsu:Id\",\r\n        id,\r\n      );\r\n    } else {\r\n      node.setAttribute(\"Id\", id);\r\n    }\r\n\r\n    return id;\r\n  }\r\n\r\n  /**\r\n   * Create the SignedInfo element\r\n   *\r\n   */\r\n  private createSignedInfo(doc, prefix) {\r\n    if (typeof this.canonicalizationAlgorithm !== \"string\") {\r\n      throw new Error(\r\n        \"Missing canonicalizationAlgorithm when trying to create signed info for XML\",\r\n      );\r\n    }\r\n    const transform = this.findCanonicalizationAlgorithm(this.canonicalizationAlgorithm);\r\n    const algo = this.findSignatureAlgorithm(this.signatureAlgorithm);\r\n    let currentPrefix;\r\n\r\n    currentPrefix = prefix || \"\";\r\n    currentPrefix = currentPrefix ? `${currentPrefix}:` : currentPrefix;\r\n\r\n    let res = `<${currentPrefix}SignedInfo>`;\r\n    res += `<${currentPrefix}CanonicalizationMethod Algorithm=\"${transform.getAlgorithmName()}\"`;\r\n    if (utils.isArrayHasLength(this.inclusiveNamespacesPrefixList)) {\r\n      res += \">\";\r\n      res += `<InclusiveNamespaces PrefixList=\"${this.inclusiveNamespacesPrefixList.join(\r\n        \" \",\r\n      )}\" xmlns=\"${transform.getAlgorithmName()}\"/>`;\r\n      res += `</${currentPrefix}CanonicalizationMethod>`;\r\n    } else {\r\n      res += \" />\";\r\n    }\r\n    res += `<${currentPrefix}SignatureMethod Algorithm=\"${algo.getAlgorithmName()}\" />`;\r\n\r\n    res += this.createReferences(doc, prefix);\r\n    res += `</${currentPrefix}SignedInfo>`;\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Create the Signature element\r\n   *\r\n   */\r\n  private createSignature(prefix?: string) {\r\n    let xmlNsAttr = \"xmlns\";\r\n\r\n    if (prefix) {\r\n      xmlNsAttr += `:${prefix}`;\r\n      prefix += \":\";\r\n    } else {\r\n      prefix = \"\";\r\n    }\r\n\r\n    const signatureValueXml = `<${prefix}SignatureValue>${this.signatureValue}</${prefix}SignatureValue>`;\r\n    //the canonicalization requires to get a valid xml node.\r\n    //we need to wrap the info in a dummy signature since it contains the default namespace.\r\n    const dummySignatureWrapper = `<${prefix}Signature ${xmlNsAttr}=\"http://www.w3.org/2000/09/xmldsig#\">${signatureValueXml}</${prefix}Signature>`;\r\n\r\n    const doc = new xmldom.DOMParser().parseFromString(dummySignatureWrapper);\r\n\r\n    // Because we are using a dummy wrapper hack described above, we know there will be a `firstChild`\r\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\r\n    return doc.documentElement.firstChild!;\r\n  }\r\n\r\n  /**\r\n   * Returns just the signature part, must be called only after {@link computeSignature}\r\n   *\r\n   * @returns The signature XML.\r\n   */\r\n  getSignatureXml(): string {\r\n    return this.signatureXml;\r\n  }\r\n\r\n  /**\r\n   * Returns the original xml with Id attributes added on relevant elements (required for validation), must be called only after {@link computeSignature}\r\n   *\r\n   * @returns The original XML with IDs.\r\n   */\r\n  getOriginalXmlWithIds(): string {\r\n    return this.originalXmlWithIds;\r\n  }\r\n\r\n  /**\r\n   * Returns the original xml document with the signature in it, must be called only after {@link computeSignature}\r\n   *\r\n   * @returns The signed XML.\r\n   */\r\n  getSignedXml(): string {\r\n    return this.signedXml;\r\n  }\r\n}\r\n"]}